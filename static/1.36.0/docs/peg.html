
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Parsing Expression Grammars</title>
    <meta name="description" content="Janet is a functional and imperative programming language. It runs on Windows, Linux, macOS, FreeBSD and *nix.">
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" charset="utf-8">
    <link rel="stylesheet" href="../css/docpage.css" type="text/css" media="screen" charset="utf-8">
    <link rel="shortcut icon" href="../assets/favicon.ico">

    <!-- Open Graph -->
    <meta property="og:description" content="Janet is a functional and imperative programming language. It runs on Windows, Linux, macOS, FreeBSD and *nix." />
    <meta property="og:title" content="Parsing Expression Grammars" />
    <meta property="og:type" content="website" />
  </head>
  <body>

    <div id="toc-toggle" class="open">
      <div class="bar topbar"></div>
      <div class="bar"></div>
      <div class="bar botbar"></div>
    </div>
    <iframe class="search-bar" src="https://duckduckgo.com/search.html?site=janet-lang.org&prefill=Search janet-lang.org" frameborder="0"></iframe>
    <script charset="utf-8">
      function toggleToc() {
        var toggler = document.getElementById('toc-toggle');
        var wrapper = document.querySelector('.toc');
        wrapper.classList.toggle('toc-hidden');
        toggler.classList.toggle('open');
        if (window.localStorage) {
          window.localStorage.setItem('show-toc', toggler.classList.contains('open'));
        }
      }
      function addTocToggle() {
        var el = document.getElementById('toc-toggle');
        if (!window.localStorage || window.localStorage.getItem('show-toc') === 'true') {
          toggleToc()
        }
        el.addEventListener('click', toggleToc);
      }
      window.addEventListener('DOMContentLoaded', addTocToggle);
    </script>

    

    <div class="twocol">
      <div class="toc show-toc">
        <ul>
          <li><span><a href="../index.html">Home</a></span></li><li class="caret"><span><a href="index.html">Documentation</a></span><ul><li><span><a href="syntax.html">Syntax and the Parser</a></span></li><li><span><a href="specials.html">Special Forms</a></span></li><li><span><a href="numbers.html">Numbers and Arithmetic</a></span></li><li><span><a href="comparison.html">Comparison Operators</a></span></li><li><span><a href="bindings.html">Bindings (def and var)</a></span></li><li><span><a href="flow.html">Flow</a></span></li><li><span><a href="functions.html">Functions</a></span></li><li><span><a href="strings.html">Strings, Keywords, and Symbols</a></span></li><li><span><a href="loop.html">Looping</a></span></li><li><span><a href="macros.html">Macros</a></span></li><li class="caret"><span><a href="data_structures/index.html">Data Structures</a></span><ul><li><span><a href="data_structures/arrays.html">Arrays</a></span></li><li><span><a href="data_structures/buffers.html">Buffers</a></span></li><li><span><a href="data_structures/tables.html">Tables</a></span></li><li><span><a href="data_structures/structs.html">Structs</a></span></li><li><span><a href="data_structures/tuples.html">Tuples</a></span></li></ul></li><li><span><a href="destructuring.html">Destructuring</a></span></li><li class="caret"><span><a href="fibers/index.html">Fibers</a></span><ul><li><span><a href="fibers/dynamic_bindings.html">Dynamic Bindings</a></span></li><li><span><a href="fibers/error_handling.html">Errors</a></span></li></ul></li><li><span><a href="modules.html">Modules</a></span></li><li><span><a href="object_oriented.html">Object-Oriented Programming</a></span></li><li><span class="selected"><a href="peg.html">Parsing Expression Grammars</a></span></li><li><span><a href="prototypes.html">Prototypes</a></span></li><li><span><a href="abstract_machine.html">The Janet Abstract Machine</a></span></li><li><span><a href="event_loop.html">The Event Loop</a></span></li><li><span><a href="threads.html">Multithreading</a></span></li><li><span><a href="networking.html">Networking</a></span></li><li class="caret"><span><a href="process_management/index.html">Process Management</a></span><ul><li><span><a href="process_management/execute.html">Executing</a></span></li><li><span><a href="process_management/spawn.html">Spawning</a></span></li></ul></li><li><span><a href="documentation.html">Documentation</a></span></li><li><span><a href="jpm.html">jpm</a></span></li><li><span><a href="linting.html">Linting</a></span></li><li><span><a href="ffi.html">Foreign Function Interface</a></span></li></ul></li><li class="caret"><span><a href="../api/index.html">API</a></span><ul><li><span><a href="../api/array.html">array</a></span></li><li><span><a href="../api/buffer.html">buffer</a></span></li><li><span><a href="../api/bundle.html">bundle</a></span></li><li><span><a href="../api/debug.html">debug</a></span></li><li><span><a href="../api/ev.html">ev</a></span></li><li><span><a href="../api/ffi.html">ffi</a></span></li><li><span><a href="../api/fiber.html">fiber</a></span></li><li><span><a href="../api/file.html">file</a></span></li><li><span><a href="../api/int.html">int</a></span></li><li class="caret"><span><a href="../api/jpm/index.html">jpm</a></span><ul><li><span><a href="../api/jpm/rules.html">rules</a></span></li><li><span><a href="../api/jpm/cc.html">cc</a></span></li><li><span><a href="../api/jpm/cgen.html">cgen</a></span></li><li><span><a href="../api/jpm/cli.html">cli</a></span></li><li><span><a href="../api/jpm/commands.html">commands</a></span></li><li><span><a href="../api/jpm/config.html">config</a></span></li><li><span><a href="../api/jpm/make-config.html">make-config</a></span></li><li><span><a href="../api/jpm/dagbuild.html">dagbuild</a></span></li><li><span><a href="../api/jpm/pm.html">pm</a></span></li><li><span><a href="../api/jpm/scaffold.html">scaffold</a></span></li><li><span><a href="../api/jpm/shutil.html">shutil</a></span></li></ul></li><li><span><a href="../api/math.html">math</a></span></li><li><span><a href="../api/module.html">module</a></span></li><li><span><a href="../api/net.html">net</a></span></li><li><span><a href="../api/os.html">os</a></span></li><li><span><a href="../api/peg.html">peg</a></span></li><li><span><a href="../api/parser.html">parser</a></span></li><li class="caret"><span><a href="../api/spork/index.html">spork</a></span><ul><li><span><a href="../api/spork/argparse.html">argparse</a></span></li><li><span><a href="../api/spork/base64.html">base64</a></span></li><li><span><a href="../api/spork/cc.html">cc</a></span></li><li><span><a href="../api/spork/cjanet.html">cjanet</a></span></li><li><span><a href="../api/spork/crc.html">crc</a></span></li><li><span><a href="../api/spork/channel.html">channel</a></span></li><li><span><a href="../api/spork/cron.html">cron</a></span></li><li><span><a href="../api/spork/data.html">data</a></span></li><li><span><a href="../api/spork/ev-utils.html">ev-utils</a></span></li><li><span><a href="../api/spork/fmt.html">fmt</a></span></li><li><span><a href="../api/spork/generators.html">generators</a></span></li><li><span><a href="../api/spork/getline.html">getline</a></span></li><li><span><a href="../api/spork/htmlgen.html">htmlgen</a></span></li><li><span><a href="../api/spork/http.html">http</a></span></li><li><span><a href="../api/spork/httpf.html">httpf</a></span></li><li><span><a href="../api/spork/infix.html">infix</a></span></li><li><span><a href="../api/spork/json.html">json</a></span></li><li><span><a href="../api/spork/mdz.html">mdz</a></span></li><li><span><a href="../api/spork/math.html">math</a></span></li><li><span><a href="../api/spork/misc.html">misc</a></span></li><li><span><a href="../api/spork/netrepl.html">netrepl</a></span></li><li><span><a href="../api/spork/pgp.html">pgp</a></span></li><li><span><a href="../api/spork/build-rules.html">build-rules</a></span></li><li><span><a href="../api/spork/path.html">path</a></span></li><li><span><a href="../api/spork/randgen.html">randgen</a></span></li><li><span><a href="../api/spork/rawterm.html">rawterm</a></span></li><li><span><a href="../api/spork/regex.html">regex</a></span></li><li><span><a href="../api/spork/rpc.html">rpc</a></span></li><li><span><a href="../api/spork/schema.html">schema</a></span></li><li><span><a href="../api/spork/sh.html">sh</a></span></li><li><span><a href="../api/spork/msg.html">msg</a></span></li><li><span><a href="../api/spork/stream.html">stream</a></span></li><li><span><a href="../api/spork/tasker.html">tasker</a></span></li><li><span><a href="../api/spork/temple.html">temple</a></span></li><li><span><a href="../api/spork/test.html">test</a></span></li><li><span><a href="../api/spork/tarray.html">tarray</a></span></li><li><span><a href="../api/spork/utf8.html">utf8</a></span></li><li><span><a href="../api/spork/zip.html">zip</a></span></li></ul></li><li><span><a href="../api/string.html">string</a></span></li><li><span><a href="../api/table.html">table</a></span></li><li><span><a href="../api/misc.html">misc</a></span></li><li><span><a href="../api/tuple.html">tuple</a></span></li></ul></li><li class="caret"><span><a href="../capi/index.html">C API</a></span><ul><li><span><a href="../capi/wrapping.html">Wrapping Types</a></span></li><li><span><a href="../capi/embedding.html">Embedding</a></span></li><li><span><a href="../capi/configuration.html">Configuration</a></span></li><li><span><a href="../capi/array.html">Array C API</a></span></li><li><span><a href="../capi/buffer.html">Buffer C API</a></span></li><li><span><a href="../capi/table.html">Table C API</a></span></li><li><span><a href="../capi/fiber.html">Fiber C API</a></span></li><li><span><a href="../capi/memory-model.html">Memory Model</a></span></li><li><span><a href="../capi/writing-c-functions.html">Writing C Functions</a></span></li></ul></li>
        </ul>
      </div>
      <div class="content-wrapper main-content">
        <h4 class="subtitle">Janet 1.36.0-c0d7a49 Documentation<br>(Other Versions:
          
          <a href="../../1.35.0/docs/peg.html">1.35.0</a>
          
          <a href="../../1.34.0/docs/peg.html">1.34.0</a>
          
          <a href="../../1.31.0/docs/peg.html">1.31.0</a>
          
          <a href="../../1.29.1/docs/peg.html">1.29.1</a>
          
          <a href="../../1.28.0/docs/peg.html">1.28.0</a>
          
          <a href="../../1.27.0/docs/peg.html">1.27.0</a>
          
          <a href="../../1.26.0/docs/peg.html">1.26.0</a>
          
          <a href="../../1.25.1/docs/peg.html">1.25.1</a>
          
          <a href="../../1.24.0/docs/peg.html">1.24.0</a>
          
          <a href="../../1.23.0/docs/peg.html">1.23.0</a>
          
          <a href="../../1.22.0/docs/peg.html">1.22.0</a>
          
          <a href="../../1.21.0/docs/peg.html">1.21.0</a>
          
          <a href="../../1.20.0/docs/peg.html">1.20.0</a>
          
          <a href="../../1.19.0/docs/peg.html">1.19.0</a>
          
          <a href="../../1.18.1/docs/peg.html">1.18.1</a>
          
          <a href="../../1.17.1/docs/peg.html">1.17.1</a>
          
          <a href="../../1.16.1/docs/peg.html">1.16.1</a>
          
          <a href="../../1.15.0/docs/peg.html">1.15.0</a>
          
          <a href="../../1.13.1/docs/peg.html">1.13.1</a>
          
          <a href="../../1.12.2/docs/peg.html">1.12.2</a>
          
          <a href="../../1.11.1/docs/peg.html">1.11.1</a>
          
          <a href="../../1.10.1/docs/peg.html">1.10.1</a>
          
          <a href="../../1.9.1/docs/peg.html">1.9.1</a>
          
          <a href="../../1.8.1/docs/peg.html">1.8.1</a>
          
          <a href="../../1.7.0/docs/peg.html">1.7.0</a>
          
          <a href="../../1.6.0/docs/peg.html">1.6.0</a>
          
          <a href="../../1.5.1/docs/peg.html">1.5.1</a>
          
          <a href="../../1.5.0/docs/peg.html">1.5.0</a>
          
          <a href="../../1.4.0/docs/peg.html">1.4.0</a>
          
          <a href="../../1.3.1/docs/peg.html">1.3.1</a>
          )</h4>
        <h1 class="subtitle">Parsing Expression Grammars</h1>
        <div class="prevnext-bar">
          <span class="prev"><a href="object_oriented.html"><span class="prevnext-text">Object-Oriented Programming</span></a></span>

          <span class="next"><a href="prototypes.html"><span class="prevnext-text">Prototypes</span></a></span>
        </div>
        

<p>A common programming task is recognizing patterns in text, be it filtering
emails from a list or extracting data from a CSV file. Programming languages and
libraries usually offer a number of tools for this, including prebuilt parsers,
simple operations on strings (splitting a string on commas), and regular
expressions.  The pre-built or custom-built parser is usually the most robust
solution, but can be very complex to maintain and may not exist for many
languages. String functions are not powerful enough for a large class of
languages, and regular expressions can be hard to read (which characters are
escaped?) and under-powered (don't parse HTML with regex!).
</p>
<p>PEGs, or Parsing Expression Grammars, are another formalism for recognizing
languages. PEGs are easier to write than a custom parser and more powerful than
regular expressions. They also can produce grammars that are easily
understandable and fast. PEGs can also be compiled to a bytecode format that can
be reused. Janet offers the <code class="mendoza-code">peg</code> module for writing and evaluating PEGs.
</p>
<p>Janet's <code class="mendoza-code">peg</code> module borrows syntax and ideas from both LPeg and REBOL/Red
parse module. Janet has no built-in regex module because PEGs offer a superset
of the functionality of regular expressions.
</p>
<p>Below is a simple example for checking if a string is a valid IP address. Notice
how the grammar is descriptive enough that you can read it even if you don't
know the PEG syntax (example is translated from a
<a href="https://www.red-lang.org/2013/11/041-introducing-parse.html">RED language blog post</a>).
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">ip-address</span>
 '{<span class="mdzsyn-keyword">:dig</span> (<span class="mdzsyn-coresym">range</span> <span class="mdzsyn-string">"09"</span>)
   <span class="mdzsyn-keyword">:0-4</span> (<span class="mdzsyn-coresym">range</span> <span class="mdzsyn-string">"04"</span>)
   <span class="mdzsyn-keyword">:0-5</span> (<span class="mdzsyn-coresym">range</span> <span class="mdzsyn-string">"05"</span>)
   <span class="mdzsyn-keyword">:byte</span> (<span class="mdzsyn-symbol">choice</span>
           (<span class="mdzsyn-symbol">sequence</span> <span class="mdzsyn-string">"25"</span> <span class="mdzsyn-keyword">:0-5</span>)
           (<span class="mdzsyn-symbol">sequence</span> <span class="mdzsyn-string">"2"</span> <span class="mdzsyn-keyword">:0-4</span> <span class="mdzsyn-keyword">:dig</span>)
           (<span class="mdzsyn-symbol">sequence</span> <span class="mdzsyn-string">"1"</span> <span class="mdzsyn-keyword">:dig</span> <span class="mdzsyn-keyword">:dig</span>)
           (<span class="mdzsyn-symbol">between</span> <span class="mdzsyn-number">1</span> <span class="mdzsyn-number">2</span> <span class="mdzsyn-keyword">:dig</span>))
   <span class="mdzsyn-keyword">:main</span> (<span class="mdzsyn-symbol">sequence</span> <span class="mdzsyn-keyword">:byte</span> <span class="mdzsyn-string">"."</span> <span class="mdzsyn-keyword">:byte</span> <span class="mdzsyn-string">"."</span> <span class="mdzsyn-keyword">:byte</span> <span class="mdzsyn-string">"."</span> <span class="mdzsyn-keyword">:byte</span>)})

(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">ip-address</span> <span class="mdzsyn-string">"0.0.0.0"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">ip-address</span> <span class="mdzsyn-string">"elephant"</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">ip-address</span> <span class="mdzsyn-string">"256.0.0.0"</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">ip-address</span> <span class="mdzsyn-string">"0.0.0.0more text"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span></code></pre><h2 id="The-API">The API
</h2>
<p>The <code class="mendoza-code">peg</code> module has few functions because the complexity is exposed
through the pattern syntax. Note that there is only one match function,
<code class="mendoza-code">peg/match</code>. Variations on matching, such as parsing or searching, can be
implemented inside patterns.  PEGs can also be compiled ahead of time with
<code class="mendoza-code">peg/compile</code> if a PEG will be reused many times.
</p>
<h3><code class="mendoza-code">(peg/match peg text [,start=0] &amp; arguments)</code>
</h3>
<p>Match a PEG against some text. Returns an array of captured data if the text
matches, or <code class="mendoza-code">nil</code> if there is no match. The caller can provide an optional
<code class="mendoza-code">start</code> index to begin matching, otherwise the PEG starts on the first
character of text. A PEG can either be a compiled PEG object or PEG source.
</p>
<h3><code class="mendoza-code">(peg/compile peg)</code>
</h3>
<p>Compiles a PEG source data structure into a new PEG. Throws an error if there
are problems with the PEG code.
</p>
<h2 id="Primitive-patterns">Primitive patterns
</h2>
<p>Larger patterns are built up with primitive patterns, which recognize individual
characters, string literals, or a given number of characters. A character in
Janet is considered a byte, so PEGs will work on any string of bytes. No special
meaning is given to the <code class="mendoza-code">0</code> byte, or the string terminator as in many
languages.
</p>
<table>
    <tr><th>Pattern Signature</th>
        <th>What it matches</th></tr>

    <tr><td>"cat" (a string)</td>
        <td> The literal string. </td></tr>

    <tr><td>3 (an integer)</td>
        <td> 
		If positive, matches a number of characters, and advances that many characters.
		If 0, counts as an (empty string) match.
        If negative, matches if not that many characters and does not advance.
        For example, -1 will match the end of a string. </td></tr>

    <tr><td><code class="mendoza-code">(range "az" "AZ")</code> </td>
        <td> Matches characters in a range and advances 1 character. Multiple
        ranges can be combined together. </td></tr>

    <tr><td><code class="mendoza-code">(set "abcd")</code></td>
        <td> Match any character in the argument string. Advances 1 character.
        </td></tr>

    <tr><td><code class="mendoza-code">true</code></td>
        <td> Always matches. Does not advance any characters. Epsilon in NFA.
        </td></tr>

    <tr><td><code class="mendoza-code">false</code></td>
        <td> Never matches. Does not advance any characters. Equivalent to
        <code class="mendoza-code">(! true)</code>.
        </td></tr>
</table><p>Primitive patterns are not that useful by themselves, but can be passed to
<code class="mendoza-code">peg/match</code> and <code class="mendoza-code">peg/compile</code> like any other pattern.
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-string">"hello"</span> <span class="mdzsyn-string">"hello"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-string">"hello"</span> <span class="mdzsyn-string">"hi"</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-number">1</span> <span class="mdzsyn-string">"hi"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-number">1</span> <span class="mdzsyn-string">""</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> '(<span class="mdzsyn-coresym">range</span> <span class="mdzsyn-string">"AZ"</span>) <span class="mdzsyn-string">"F"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span>
(<span class="mdzsyn-coresym">peg/match</span> '(<span class="mdzsyn-coresym">range</span> <span class="mdzsyn-string">"AZ"</span>) <span class="mdzsyn-string">"-"</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> '(<span class="mdzsyn-coresym">set</span> <span class="mdzsyn-string">"AZ"</span>) <span class="mdzsyn-string">"F"</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> '(<span class="mdzsyn-coresym">set</span> <span class="mdzsyn-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>) <span class="mdzsyn-string">"F"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span></code></pre><h2 id="Combining-patterns">Combining patterns
</h2>
<p>These primitive patterns can be combined with several combinators to match a
wide number of languages. These combinators can be thought of as the looping and
branching forms in a traditional language (that is how they are implemented when
compiled to bytecode).
</p>
<table>
    <tr><th>Pattern Signature</th>
        <th>What it matches</th></tr>

    <tr><td><code class="mendoza-code">(choice a b c ...)</code> </td>
        <td> Tries to match a, then b, and so on. Will succeed on the first
        successful match, and fails if none of the arguments match the text. </td></tr>

    <tr><td><code class="mendoza-code">(+ a b c ...)</code> </td>
        <td> Alias for <code class="mendoza-code">(choice a b c ...)</code> </td></tr>

    <tr><td><code class="mendoza-code">(sequence a b c)</code> </td>
        <td> Tries to match a, b, c and so on in sequence. If any of these
        arguments fail to match the text, the whole pattern fails. </td></tr>

    <tr><td><code class="mendoza-code">(* a b c ...)</code> </td>
        <td> Alias for <code class="mendoza-code">(sequence a b c ...)</code> </td></tr>

    <tr><td><code class="mendoza-code">(any x)</code> </td>
        <td> Matches 0 or more repetitions of x. </td></tr>

    <tr><td><code class="mendoza-code">(some x)</code> </td>
        <td> Matches 1 or more repetitions of x. </td></tr>

    <tr><td><code class="mendoza-code">(between min max x)</code> </td>
        <td> Matches between min and max (inclusive) repetitions of x. </td></tr>

    <tr><td><code class="mendoza-code">(at-least n x)</code> </td>
        <td> Matches at least n repetitions of x. </td></tr>

    <tr><td><code class="mendoza-code">(at-most n x)</code> </td>
        <td>  Matches at most n repetitions of x. </td></tr>

    <tr><td><code class="mendoza-code">(repeat n x)</code> </td>
        <td> Matches exactly n repetitions of x. </td></tr>

    <tr><td><code class="mendoza-code">(if cond patt)</code> </td>
        <td> Tries to match patt only if cond matches as well. cond will not
        produce any captures. </td></tr>

    <tr><td><code class="mendoza-code">(if-not cond patt)</code> </td>
        <td> Tries to match only if cond does not match. cond will not produce
        any captures. </td></tr>

    <tr><td><code class="mendoza-code">(not patt)</code> </td>
        <td> Matches only if patt does not match. Will not produce captures or
        advance any characters. </td></tr>

    <tr><td><code class="mendoza-code">(! patt)</code> </td>
    <td> Alias for <code class="mendoza-code">(not patt)</code> </td></tr>

    <tr><td><code class="mendoza-code">(look offset patt)</code> </td>
        <td> Matches only if patt matches at a fixed offset. offset can be any
        integer. patt will not produce captures and the peg will not advance any
        characters. </td></tr>

    <tr><td><code class="mendoza-code">(&gt; offset patt)</code> </td>
        <td> Alias for <code class="mendoza-code">(look offset patt)</code> </td></tr>

    <tr><td><code class="mendoza-code">(to patt)</code> </td>
        <td> Match up to patt (but not including it). If the end of the input
             is reached and patt is not matched, the entire pattern does not
             match. </td></tr>

    <tr><td><code class="mendoza-code">(thru patt)</code> </td>
        <td> Match up through patt (thus including it). If the end of the
             input is reached and patt is not matched, the entire pattern
             does not match. </td></tr>

    <tr><td><code class="mendoza-code">(backmatch ?tag)</code> </td>
        <td> If tag is provided, matches against the tagged capture.  If no
             tag is provided, matches against the last capture, but only if
             that capture is untagged.  The peg advances if there was a
             match.</td></tr>

    <tr><td><code class="mendoza-code">(opt patt)</code> </td>
        <td> Alias for <code class="mendoza-code">(between 0 1 patt)</code> </td></tr>

    <tr><td><code class="mendoza-code">(? patt)</code> </td>
        <td> Alias for <code class="mendoza-code">(between 0 1 patt)</code> </td></tr>

    <tr><td><code class="mendoza-code">(n patt)</code> </td>
        <td> Alias for <code class="mendoza-code">(repeat n patt)</code> </td></tr>

    <tr><td><code class="mendoza-code">(sub window-patt patt)</code> </td>
        <td> Match <code class="mendoza-code">window-patt</code>, and if it succeeds match
             <code class="mendoza-code">patt</code> against the bytes that <code class="mendoza-code">window-patt</code> matched.
             <code class="mendoza-code">patt</code> cannot match more than <code class="mendoza-code">window-patt</code>; it will
             see end-of-input at the end of the substring matched by
             <code class="mendoza-code">window-patt</code>. If <code class="mendoza-code">patt</code> also succeeds, <code class="mendoza-code">sub</code> will
             advance to the end of what <code class="mendoza-code">window-patt</code> matched. </td></tr></table><p>PEGs try to match an input text with a pattern in a greedy manner.  This means
that if a rule fails to match, that rule will fail and not try again. The only
backtracking provided in a PEG is provided by the <code class="mendoza-code">(choice x y z ...)</code>
special, which will try rules in order until one succeeds, and the whole pattern
succeeds. If no sub-pattern succeeds, then the whole pattern fails. Note that
this means that the order of <code class="mendoza-code">x y z</code> in choice <strong>does</strong> matter. If
<code class="mendoza-code">y</code> matches everything that <code class="mendoza-code">z</code> matches, <code class="mendoza-code">z</code> will never succeed.
</p>
<h2 id="Captures">Captures
</h2>
<p>So far we have only been concerned with "does this text match this language?".
This is useful, but it is often more useful to extract data from text if it does
match a PEG. The <code class="mendoza-code">peg</code> module uses the concept of a capture stack to
extract data from text. As the PEG is trying to match a piece of text, some
forms may push Janet values onto the capture stack as a side effect. If the text
matches the main PEG language, <code class="mendoza-code">(peg/match)</code> will return the final capture
stack as an array.
</p>
<p>Capture specials will only push captures to the capture stack if their child
pattern matches the text.  Most captures specials will match the same text as
their first argument pattern. In addition, most specials that produce captures
can take an optional argument <code class="mendoza-code">tag</code> that applies a keyword tag to the
capture.  These tagged captures can then be recaptured via the <code class="mendoza-code">(backref
tag)</code> special in subsequent matches.  Tagged captures, when combined with the
<code class="mendoza-code">(cmt)</code> special, provide a powerful form of look-behind that can make many
grammars simpler.
</p>
<table>
    <tr><th>Pattern Signature</th>
        <th>What it matches</th></tr>

    <tr><td><code class="mendoza-code">(capture patt ?tag)</code> </td>
        <td> Captures all of the text in patt if patt matches. If patt contains
        any captures, then those captures will be pushed on to the capture
        stack before the total text. </td></tr>

    <tr><td><code class="mendoza-code">(&lt;- patt ?tag)</code> </td>
        <td> Alias for <code class="mendoza-code">(capture patt ?tag)</code> </td></tr>

    <tr><td><code class="mendoza-code">(quote patt ?tag)</code> </td>
        <td> Another alias for <code class="mendoza-code">(capture patt ?tag)</code>. This allows code
        like <code class="mendoza-code">'patt</code> to capture a pattern. </td></tr>

    <tr><td><code class="mendoza-code">(group patt ?tag) </code> </td>
        <td> Captures an array of all of the captures in patt. </td></tr>

    <tr><td><code class="mendoza-code">(replace patt subst ?tag)</code> </td>
        <td> Replaces the captures produced by patt by applying subst to them.
        If subst is a table or struct, will push <code class="mendoza-code">(get subst last-capture)</code>
        to the capture stack after removing the old captures. If subst is a
        function, will call subst with the captures of patt as arguments and
        push the result to the capture stack. Otherwise, will push subst
        literally to the capture stack. </td></tr>

    <tr><td><code class="mendoza-code">(/ patt subst ?tag)</code> </td>
        <td> Alias for <code class="mendoza-code">(replace patt subst ?tag)</code> </td></tr>

    <tr><td><code class="mendoza-code">(constant k ?tag)</code> </td>
        <td> Captures a constant value and advances no characters. </td></tr>

    <tr><td><code class="mendoza-code">(argument n ?tag)</code> </td>
        <td> Captures the nth extra argument to the match function and does not
        advance. </td></tr>

    <tr><td><code class="mendoza-code">(position ?tag)</code> </td>
        <td> Captures the current index into the text and advances no input. </td></tr>

    <tr><td><code class="mendoza-code">($ ?tag)</code> </td>
        <td> Alias for <code class="mendoza-code">(position ?tag)</code>. </td></tr>

    <tr><td><code class="mendoza-code">(column ?tag)</code> </td>
        <td> Captures the column number of the current position in the matched
        text. </td></tr>

    <tr><td><code class="mendoza-code">(line ?tag)</code> </td>
        <td> Captures the line number of the current position in the matched
        text. </td></tr>

    <tr><td><code class="mendoza-code">(accumulate patt ?tag)</code> </td>
        <td> Capture a string that is the concatenation of all captures in patt.
        This will try to be efficient and not create intermediate strings if
        possible. </td></tr>

    <tr><td><code class="mendoza-code">(% patt ?tag)</code> </td>
        <td> Alias for <code class="mendoza-code">(accumulate patt ?tag)</code> </td></tr>

    <tr><td><code class="mendoza-code">(cmt patt fun ?tag)</code> </td>
        <td> Invokes fun with all of the captures of patt as arguments (if patt
        matches). If the result is truthy, then captures the result. The whole
        expression fails if fun returns false or nil. </td></tr>

    <tr><td><code class="mendoza-code">(backref tag ?tag)</code> </td>
        <td> Duplicates the last capture with the tag <code class="mendoza-code">tag</code>. If no such
        capture exists then the match fails. </td></tr>

    <tr><td><code class="mendoza-code">(-&gt; tag ?tag)</code> </td>
        <td> Alias for <code class="mendoza-code">(backref tag)</code>. </td></tr>

    <tr><td><code class="mendoza-code">(unref patt ?tag)</code> </td>
        <td>Lets a user "scope" tagged captures.
        After the rule has matched, all captures with the given tag can no longer be
        referred to by their tag. However, such captures from outside
        rule are kept as is. If no tag is given, all tagged captures from rule
        are unreferenced. Note that this doesn't drop the captures, merely
        removes their association with the tag. This means subsequent calls to
        backref and backmatch will no longer "see" these tagged captures. </td></tr>

    <tr><td><code class="mendoza-code">(error ?patt)</code> </td>
        <td> Throws a Janet error.  If optional argument <code class="mendoza-code">patt</code> is
        provided and it matches successfully, the error thrown will be the
        last capture of <code class="mendoza-code">patt</code>, or a generic error if <code class="mendoza-code">patt</code>
        produces no captures. If no argument is provided, a generic error is
        thrown. If <code class="mendoza-code">patt</code> does not match, no error will be thrown.
        </td></tr>

    <tr><td><code class="mendoza-code">(drop patt)</code> </td>
        <td> Ignores (drops) all captures from patt. </td></tr>

    <tr><td><code class="mendoza-code">(uint num-bytes ?tag)</code> </td>
        <td> Capture a little endian, unsigned, two's complement integer from 
        <code class="mendoza-code">num-bytes</code>. Works for 1 to 8 byte integers. </td></tr>

    <tr><td><code class="mendoza-code">(uint-be num-bytes ?tag)</code> </td>
        <td> Capture a big endian, unsigned, two's complement integer from 
        <code class="mendoza-code">num-bytes</code>. Works for 1 to 8 byte integers. </td></tr>

    <tr><td><code class="mendoza-code">(int num-bytes ?tag)</code> </td>
        <td> Capture a little endian, signed, two's complement integer from 
        <code class="mendoza-code">num-bytes</code>. Works for 1 to 8 byte integers. </td></tr>

    <tr><td><code class="mendoza-code">(int-be num-bytes ?tag)</code> </td>
        <td> Capture a big endian, signed, two's complement integer from 
        <code class="mendoza-code">num-bytes</code>. Works for 1 to 8 byte integers. </td></tr>

    <tr><td><code class="mendoza-code">(lenprefix n patt)</code> </td>
        <td> Matches n repetitions of a pattern, where n is supplied from other
        parsed input and is not a constant. </td></tr>

    <tr><td><code class="mendoza-code">(number patt ?base ?tag)</code> </td>
        <td> Capture a number parsed from the matched pattern. This uses the
         same parser as Janet itself, so it supports all numeric notation
         allowed in Janet files. To tag the capture without forcing a
         particular base, use <code class="mendoza-code">(number patt nil :tag)</code>. </td></tr></table><h2 id="Grammars-and-recursion">Grammars and recursion
</h2>
<p>The feature that makes PEGs so much more powerful than pattern matching
solutions like (vanilla) regex is mutual recursion.  To do recursion in a PEG,
you can wrap multiple patterns in a grammar, which is a Janet struct. The
patterns must be named by keywords, which can then be used in all sub-patterns
in the grammar.
</p>
<p>Each grammar, defined by a struct, must also have a main rule, called
<code class="mendoza-code">:main</code>, that is the pattern that the entire grammar is defined by.
</p>
<p>An example grammar that uses mutual recursion:
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">my-grammar</span>
 '{<span class="mdzsyn-keyword">:a</span> (<span class="mdzsyn-coresym">*</span> <span class="mdzsyn-string">"a"</span> <span class="mdzsyn-keyword">:b</span> <span class="mdzsyn-string">"a"</span>)
   <span class="mdzsyn-keyword">:b</span> (<span class="mdzsyn-coresym">*</span> <span class="mdzsyn-string">"b"</span> (<span class="mdzsyn-coresym">+</span> <span class="mdzsyn-keyword">:a</span> <span class="mdzsyn-number">0</span>) <span class="mdzsyn-string">"b"</span>)
   <span class="mdzsyn-keyword">:main</span> (<span class="mdzsyn-coresym">*</span> <span class="mdzsyn-string">"("</span> <span class="mdzsyn-keyword">:b</span> <span class="mdzsyn-string">")"</span>)})

(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">my-grammar</span> <span class="mdzsyn-string">"(bb)"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">my-grammar</span> <span class="mdzsyn-string">"(babbab)"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">my-grammar</span> <span class="mdzsyn-string">"(baab)"</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">my-grammar</span> <span class="mdzsyn-string">"(babaabab)"</span>) <span class="mdzsyn-comment"># -&gt; nil</span></code></pre><p>Keep in mind that recursion is implemented with a stack, meaning that very
recursive grammars can overflow the stack. The compiler is able to turn some
recursion into iteration via tail-call optimization, but some patterns may fail
on large inputs. It is also possible to construct (very poorly written) patterns
that will result in long loops and be very slow in general.
</p>
<h2 id="Built-in-patterns">Built-in patterns
</h2>
<p>Besides the primitive patterns and pattern combinators given above, the
<code class="mendoza-code">peg</code> module also provides a default grammar with a handful of commonly
used patterns. All of these shorthands can be defined with the combinators above
and primitive patterns, but you may see these aliases in other grammars and they
can make grammars simpler and easier to read.
</p>
<table>
    <tr><th>Name</th> <th>Expanded</th> <th>Description</th></tr>
    <tr><td><code class="mendoza-code">:d</code></td> <td><code class="mendoza-code">(range "09")</code></td> <td>Matches an ASCII digit.</td></tr>
    <tr><td><code class="mendoza-code">:a</code></td> <td><code class="mendoza-code">(range "az" "AZ")</code></td> <td>Matches an ASCII letter.</td></tr>
    <tr><td><code class="mendoza-code">:w</code></td> <td><code class="mendoza-code">(range "az" "AZ" "09")</code></td> <td>Matches an ASCII digit or letter.</td></tr>
    <tr><td><code class="mendoza-code">:s</code></td> <td><code class="mendoza-code">(set " \t\r\n\0\f\v")</code></td> <td>Matches an ASCII whitespace character.</td></tr>
    <tr><td><code class="mendoza-code">:h</code></td> <td><code class="mendoza-code">(range "09" "af" "AF")</code></td> <td>Matches a hex character.</td></tr>

    <tr><td><code class="mendoza-code">:D</code></td> <td><code class="mendoza-code">(if-not :d 1)</code></td> <td>Matches a character that is not an ASCII digit.</td></tr>
    <tr><td><code class="mendoza-code">:A</code></td> <td><code class="mendoza-code">(if-not :a 1)</code></td> <td>Matches a character that is not an ASCII letter.</td></tr>
    <tr><td><code class="mendoza-code">:W</code></td> <td><code class="mendoza-code">(if-not :w 1)</code></td> <td>Matches a character that is not an ASCII digit or letter.</td></tr>
    <tr><td><code class="mendoza-code">:S</code></td> <td><code class="mendoza-code">(if-not :s 1)</code></td> <td>Matches a character that is not ASCII whitespace.</td></tr>
    <tr><td><code class="mendoza-code">:H</code></td> <td><code class="mendoza-code">(if-not :h 1)</code></td> <td>Matches a character that is not a hex character.</td></tr>

    <tr><td><code class="mendoza-code">:d+</code></td> <td><code class="mendoza-code">(some :d)</code></td> <td>Matches 1 or more ASCII digits.</td></tr>
    <tr><td><code class="mendoza-code">:a+</code></td> <td><code class="mendoza-code">(some :a)</code></td> <td>Matches 1 or more ASCII letters.</td></tr>
    <tr><td><code class="mendoza-code">:w+</code></td> <td><code class="mendoza-code">(some :w)</code></td> <td>Matches 1 or more ASCII digits and letters.</td></tr>
    <tr><td><code class="mendoza-code">:s+</code></td> <td><code class="mendoza-code">(some :s)</code></td> <td>Matches 1 or more ASCII whitespace characters.</td></tr>
    <tr><td><code class="mendoza-code">:h+</code></td> <td><code class="mendoza-code">(some :h)</code></td> <td>Matches 1 or more hex characters.</td></tr>

    <tr><td><code class="mendoza-code">:d*</code></td> <td><code class="mendoza-code">(any :d)</code></td> <td>Matches 0 or more ASCII digits.</td></tr>
    <tr><td><code class="mendoza-code">:a*</code></td> <td><code class="mendoza-code">(any :a)</code></td> <td>Matches 0 or more ASCII letters.</td></tr>
    <tr><td><code class="mendoza-code">:w*</code></td> <td><code class="mendoza-code">(any :w)</code></td> <td>Matches 0 or more ASCII digits and letters.</td></tr>
    <tr><td><code class="mendoza-code">:s*</code></td> <td><code class="mendoza-code">(any :s)</code></td> <td>Matches 0 or more ASCII whitespace characters.</td></tr>
    <tr><td><code class="mendoza-code">:h*</code></td> <td><code class="mendoza-code">(any :h)</code></td> <td>Matches 0 or more hex characters.</td></tr>
</table><p>All of these aliases are defined in <code class="mendoza-code">default-peg-grammar</code>, which is a table
that maps from the alias name to the expanded form. You can even add your own
aliases here which are then available for all PEGs in the program. Modifiying
this table will not affect already compiled PEGs.
</p>
<h2 id="String-searching-and-other-idioms">String searching and other idioms
</h2>
<p>Although all pattern matching is done in anchored mode, operations like global
substitution and searching can be implemented with the PEG module. A simple
Janet function that produces PEGs that search for strings shows how captures and
looping specials can be composed, and how quasiquoting can be used to embed values
in patterns.
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">defn</span> <span class="mdzsyn-symbol">finder</span>
 <span class="mdzsyn-string">"Creates a peg that finds all locations of str in the text."</span>
 [<span class="mdzsyn-symbol">str</span>]
 (<span class="mdzsyn-coresym">peg/compile</span> ~(<span class="mdzsyn-symbol">any</span> (<span class="mdzsyn-coresym">+</span> (<span class="mdzsyn-coresym">*</span> (<span class="mdzsyn-symbol">$</span>) ,<span class="mdzsyn-symbol">str</span>) <span class="mdzsyn-number">1</span>))))

(<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">where-are-the-dogs?</span> (<span class="mdzsyn-symbol">finder</span> <span class="mdzsyn-string">"dog"</span>))

(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">where-are-the-dogs?</span> <span class="mdzsyn-string">"dog dog cat dog"</span>) <span class="mdzsyn-comment"># -&gt; @[0 4 12]</span>

<span class="mdzsyn-comment"># Our finder function also works on any pattern, not just strings.</span>

(<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">find-cats</span> (<span class="mdzsyn-symbol">finder</span> '(<span class="mdzsyn-coresym">*</span> <span class="mdzsyn-string">"c"</span> (<span class="mdzsyn-coresym">some</span> <span class="mdzsyn-string">"a"</span>) <span class="mdzsyn-string">"t"</span>)))

(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">find-cats</span> <span class="mdzsyn-string">"cat ct caat caaaaat cat"</span>) <span class="mdzsyn-comment"># -&gt; @[0 7 12 20]</span></code></pre><p>We can also wrap a PEG to turn it into a global substitution grammar with the
accumulate special <code class="mendoza-code">(%)</code>.
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">defn</span> <span class="mdzsyn-symbol">replacer</span>
 <span class="mdzsyn-string">"Creates a peg that replaces instances of patt with subst."</span>
 [<span class="mdzsyn-symbol">patt</span> <span class="mdzsyn-symbol">subst</span>]
 (<span class="mdzsyn-coresym">peg/compile</span> ~(<span class="mdzsyn-coresym">%</span> (<span class="mdzsyn-symbol">any</span> (<span class="mdzsyn-coresym">+</span> (<span class="mdzsyn-coresym">/</span> (<span class="mdzsyn-symbol">&lt;-</span> ,<span class="mdzsyn-symbol">patt</span>) ,<span class="mdzsyn-symbol">subst</span>) (<span class="mdzsyn-symbol">&lt;-</span> <span class="mdzsyn-number">1</span>))))))</code></pre>
        <div class="prevnext-bar">
          <span class="prev"><a href="object_oriented.html"><span class="prevnext-text">Object-Oriented Programming</span></a></span>
          <span class="next"><a href="prototypes.html"><span class="prevnext-text">Prototypes</span></a></span>
        </div>
      </div>
    </div>

    
<footer>
  &copy; Calvin Rose &amp; contributors 2024
  <div class="gentag">Generated on September 8, 2024 at 01:51:37 (UTC) with Janet 1.36.0-c0d7a49</div>
  <div class="see-problem">See a problem? Source
    <a href="https://github.com/janet-lang/janet-lang.org">on GitHub</a></div>
</footer>



  </body>
</html>
